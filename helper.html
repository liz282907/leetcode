<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>leetcode调试</title>
</head>
<body>

<!--<script src="./build/main.js"> -->

    <script>
    //-2  -1 0 0 1 2
    // var nums = [1,0,-1,0,-2,2]; [0,0,0,0]
    var target =32;
    // var nums = [-2,1,-3,4,-1,2,1,-5,4];
    var nums = [-1];
var maxSubArray = function(nums) {
    var curArr = [],lastSum = 0,resultArr = [];
    for(var i=0;i<nums.length;i++){
        if(lastSum>=0) {
            curArr.push(nums[i]);
            lastSum+= nums[i];
            resultArr[i]= [].concat(curArr);
        }
        else{
            curArr = [nums[i]];
            lastSum = nums[i];
            resultArr[i] = curArr;
        }
    }
    var result = Number.NEGATIVE_INFINITY;
    for(i=0;i<nums.length;i++){
        console.log("-----------",resultArr[i]);
        var temp = resultArr[i].reduce(function(prev,cur){return prev+=cur;},0);
        if(result < temp) result = temp;
    }
    return result;

};

var longestPalindrome = function(s) {
    var arr = s.split('');
    var result = s[0];
    for(var i=0;i<s.length;i++){
        var getResult = true;
        var j = arr.lastIndexOf(arr[i]);
        if(j===i) continue;
        var tempI = i,tempJ = j;

        while(tempI<=tempJ){
            if(arr[tempI]!==arr[tempJ]) {getResult = false;break;}
            else{
                tempI++;
                tempJ--;
            }
        }
        if(!getResult) continue;
        if(s.slice(i,j+1).length>result.length) result = s.slice(i,j+1);
    }
    return result;
};

var longestValidParentheses = function(s) {
    var stack = [],count = 0,maxCount = 0;
    for(var i=0;i<s.length;i++){
        if(s[i]==='(') {
            stack.push(s[i]);
        }
        else{
            if(stack.length>0 && stack.slice(-1)[0]==='('){
                stack.pop();
                count+=2;
                maxCount = Math.max(maxCount,count);
            }else count = 0;
        }
    }

    return maxCount;
};

// longestValidParentheses("()(()");
// longestPalindrome('aaabaaaa');


var addBinary = function(a, b) {
    var carry = 0,curV = 0,j = 0,i=0,
        result = [],length = Math.max(a.length, b.length);

    var inverseA = a.split('').reverse(),
        inverseB = b.split('').reverse();

    while (i < length && j < length) {
        var left = i >= a.length ? 0 : parseInt(inverseA[i]);
        var right = j >= b.length ? 0 : parseInt(inverseB[j]);
        var sum = left + right + carry;
        result[i] = sum % 2;
        carry = parseInt(sum / 2);
        i++;j++;    //别忘了
    }
    if(carry) result[i+1] = carry; //这边需要if判断，不能直接result[i+1] = carry

    return result.reverse().join(''); //别忘了翻转

};
// addBinary('0','0');



var maxProduct = function(nums) {
    var maxArr = [nums[0]];
    var minArr = [nums[0]];
    for(var i=1;i<nums.length;i++){
        // var lastMax = maxSoFar,lastMin = minSoFar;
        maxArr[i] = Math.max(
            maxArr[i-1]*nums[i],
            nums[i],
            minArr[i-1]*nums[i]
        );
        minArr[i] = Math.min(
            maxArr[i-1]*nums[i],
            nums[i],
            minArr[i-1]*nums[i]
        );
    }

    return maxArr[nums.length-1];
};

// maxProduct([-4,-3,-2]);

var lengthOfLIS = function(nums) {

    if(!nums.length) return 0;
    var LISArr = [[nums[0]]];
    var maxLength = 1;
    for(var i=1;i<nums.length;i++){

        var prevArr = LISArr[i-1];
        if(nums[i]<prevArr[0])
            LISArr[i] = [nums[i]]
        else{
            LISArr[i] = bisectInsert(LISArr[i-1],nums[i]);
        }
        maxLength = Math.max(maxLength,LISArr[i].length);

    }
    return maxLength;

    function bisectInsert(arr,val){
        var i=0,j = arr.length;
        while(i<j){
            mid = Math.floor((i+j)/2);
            if(arr[mid]<val) i = mid+1;
            else j = mid;
        }

        //while(arr[i]===val) i++;//如果有重复元素，找到第一个大于它的。插入。
        return arr.slice(0,i).concat(val);
    }

};

var singleNumber = function(nums) {
    var diff = 0,result = [0,0];
    for(var i=0;i<nums.length;i++){
        diff ^= nums[i];
    }
    diff &= -diff;
    for(i=0;i<nums.length;i++){
        var cur = nums[i];
        if(cur & diff ===0) result[0] ^= cur;
        else result[1] ^= cur;
    }
    return result;
};
singleNumber([1,1,3,5])

// lengthOfLIS([1,3,6,7,9,4,10,5,6]);
var numDecodings = function(s) {
    var dict = {};
    for(var i=1;i<=26;i++){
        dict[i] = true;
    }
    if(!s) return 0;

    var nums = [];
    nums[0] = s[0]==='0'?0:1;
    // nums[1] = countValid(s.substr(0,2));

    for(i=1;i<s.length;i++){
        nums[i] = 0;
        if(dict[s.substr(i-1,2)]){
            if(i<2) nums[i] += 1;
            else nums[i] += nums[i-2];
        }
        if(s[i]!=='0') nums[i] += nums[i-1];
    }
    return nums[s.length-1];
};

var numDistinct = function(s, t) {

    var numArr = [];
    for(var i=0;i<=t.length;i++){
        numArr[i] = new Array(s.length+1);
    }
    //第一行初始化。只要不断删除就可以，因此都是1
    for(var j=0;j<=s.length;j++){
        numArr[0][j] = 1;
    }
    //第一列初始化，因为t是target,现在s<t。那么无论如何都不行
    for(i=1;i<=t.length;i++)
        numArr[i][0] = 0;

    for(i=1;i<=t.length;i++)
        for(j=1;j<=s.length;j++){
            numArr[i][j] = numArr[i][j-1];
            if(s[j-1]===t[i-1]) numArr[i][j]+=numArr[i-1][j-1];
        }
    return numArr[t.length][s.length];


};
var wordBreak = function(s, wordDict) {
      var findDict = [];
     findDict[0] = true;
     for(var i=1;i<=s.length;i++) findDict[i] = false;

   for(i=1;i<=s.length;i++){
        for(var len=1;len<=i;len++){
            var temp = s.slice(i-len,i);
            if(findDict[i-len] &&(wordDict.has(temp))){
                findDict[i] = true;
                break;
            }

        }

    }
    return findDict[s.length];
};
// wordBreak('abcd',new Set(["a","abc","b","cd"]));
// numDistinct('b','a');

var lengthOfLongestSubstring = function(s) {

    var dict = {},
        max = 0,j=0;

    for(var i=0;i<s.length;i++){
        if((dict[s[i]]!==undefined))     //不能直接用!dict，因为index可能为0
            j = Math.max(j,dict[s[i]]+1);   //j左侧或右侧，所以要比较下

        max = Math.max(max,i-j+1);
        dict[s[i]] = i;

    }
    return max;


};
// lengthOfLongestSubstring("abba");


var solve = function(board) {
    if(board.length<=0) return;   //attention！防止board为空下面board[0]undefined
    var row = board.length;
    var col = board[0].length;

    var visited = new Set();

    //对第一列和最后一列
    for(var i=0;i<row;i++)
    {
        bfs(i,0,visited,board);
        bfs(i,col-1,visited,board);
    }
    //对第一行跟最后一行中每一个进行BFS，但实际上是对里面为O的当成一个子图。
    for(var j=0;j<col;j++)
    {
        bfs(0,j,visited,board);
        bfs(row-1,j,visited,board);
    }

    //与边界相联通的置为1的都置回O，其他O都置为X
    for(i=0;i<row;i++)
        for(j=0;j<col;j++){
            if(board[i][j]==='O') board[i][j] = 'X';
            if(board[i][j]==='1') board[i][j] = 'O';
        }
};

//相当于图中有若干个连通图，对每个连通图都要去建立一个队列，但是visited数组是全局的
//思路是，只要有为O的， 就相当于一个bfs的中心节点，一层层找它的邻接点是否为O，如果是，那么就放进去，传统的BFS是对所有的邻接点都push进queue.一旦这么处理了，就会把所有的与O联通的O给置1，那么内部被X包围的O就会留下，最后反转capture即可。
//注意这是一个非连通图。
function bfs(x,y,visited,board){
    var row = board.length;
    var col = board[0].length;

    var queue = [];
    visited.add(JSON.stringify([x,y]));
    if(board[x][y]!=='O') return;

    board[x][y] = '1';
    queue.push([x,y]);

    while(queue.length){
        var cur = queue.shift();
        var curX = cur[0];var curY = cur[1];
        //邻接点
        addAdj(curX-1,curY,queue,visited);
        addAdj(curX+1,curY,queue,visited);
        addAdj(curX,curY-1,queue,visited);
        addAdj(curX,curY+1,queue,visited);

    }
    function addAdj(x,y,queue,visited){
        if(x<0 || x>=row || y<0 || y>=col) return;
        if(board[x][y]==='O' && !visited.has(JSON.stringify([x,y]))){
                visited.add(JSON.stringify([x,y]));
                board[x][y] = '1';
                queue.push([x,y]);
        }
    }

}
// solve(["OOO".split(''),"OOO".split(''),"OOO".split('')])

var canFinish = function(numCourses, prerequisites) {
    var adjList = [];   //邻接矩阵
    var queue = [];//存储入度为0的点
    var inDegreeArr = [],count=0; //度数数组

    //初始化邻接表
    for(var i=0;i<numCourses;i++) adjList[i] = [];

    //now :这边构造出度邻接表。
    //before 构造的是入度邻接表// 2->1  3->1  then adjList[1] = [2,3]
    for(i=0;i<prerequisites.length;i++){
        var cur = prerequisites[i];
        adjList[cur[1]].push(cur[0]);  // 1->2 1->3  then adjList[1] = [2,3]
    }
    //构造入度数组
    for(i=0;i<numCourses;i++) inDegreeArr[i] = 0;
    for(i=0;i<numCourses;i++){
        // inDegreeArr[i] = 0;   不可以放这边
        for(var j=0;j<adjList[i].length;j++){
            var adjV = adjList[i][j];
            inDegreeArr[adjV]+=1;
        }
    }
    for(i=0;i<inDegreeArr.length;i++){
        if(inDegreeArr[i]===0) queue.push(i);
    }

    while(queue.length){
        cur = queue.shift();
        count++;
        //对它的每个邻接点，入度减1,同时，如果减了以后，入度为0，放入queue
        for(i=0;i<adjList[cur].length;i++){
            var curAdj = adjList[cur][i];
            if((--inDegreeArr[curAdj])===0) queue.push(curAdj);
        }

    }
    if(count!==numCourses) return false;
    else return true;
};



// canFinish(3,[[1,0],[2,1]]);
var canJump = function(nums) {
    var count = 0;
    backtrack(nums.length-1,nums,0);
    if(count>0) return true;
    else return false;

    function backtrack(leftSum,nums,start){
        if(leftSum===0 && start===nums.length-1){
            count++;
            return;
        }
        if(start>nums.length-1) return;

        for(var i=1;i<=nums[start];i++){
            if(leftSum<i) return;
            backtrack(leftSum-i,nums,start+i);
        }
    }
};
// canJump([2,0,0])
var myAtoi = function(str) {
    var i=0,sign=1;
    while(str[i]===' ') i++;
    var nonSpaceStr = str.slice(i);

    if(nonSpaceStr.search(/^[+-]/)!==-1) {
        sign = nonSpaceStr[0]==='-'?-1:1;
        nonSpaceStr = nonSpaceStr.slice(1);
    }

    var sum=0,numMatch = nonSpaceStr.match(/([1-9]\d*)+/);

    if(numMatch){

        var  left = nonSpaceStr.slice(0,nonSpaceStr.indexOf(numMatch[0][0]));
        if(left.search(/[^0]+/g)!==-1) return 0;

        for(i=0;i< numMatch[0].length;i++)
        sum = 10*sum + (numMatch[0][i]-'0');

        sum *= sign;

        if(Math.abs(sum)>Math.pow(2,31)-1) {
            if(sign>0) sum = Math.pow(2,31)-1;
            else sum = Math.pow(2,31)*sign;
        }
    }
    return sum;

    //2147483648 2^31-1
    // return sum;
};

// myAtoi('  -0012a42'); //010  +-2 "-2147483648"
// myAtoi("-1");

var longestCommonPrefix = function(strs) {

    if(strs.length<2) return strs[0]||"";

    var commonPrefix = "";
    strs = strs.sort(function(s1,s2){
        return s1.length<s2.length;
    });
    var i=0,j=0;
    var left = strs[0],right = strs[1];
    while(left[i]===right[j] && i<left.length && j< right.length){
        i++;
        j++;
    }
    for(;i>=0;i--){
        commonPrefix = left.slice(0,i);
        for(j=2;j<strs.length;j++){
            var curStr = strs[j];
            if(curStr.slice(0,i)!==commonPrefix) break;
        }
        if(j>=strs.length) break;    //here
    }
    return commonPrefix;
};

// longestCommonPrefix(["a","a",'b']);

var generateParenthesis = function(n) {
    var solution = ['('],options = ['(',')'];
    var result = [];
    backtrack(1,2*n-1,options);
    return result;

    function backtrack(index,total,options){
        if(index===total){
            solution[total] = ')';
            var solu = solution.join("");
            console.log(solu);
            if(isValid(solu)) result.push(solu);
            return;
        }

        for(var i=0;i<2;i++){
            solution[index] = options[i];
            backtrack(index+1,total,options);
        }
    }


};

var isValid = function(s) {
    var stack = [],dic = {'(':')'};
    for(var i=0;i<s.length;i++){
        var cur = s[i];
        if(dic[cur]) stack.push(cur);
        else{
            if(dic[stack.pop()]!==cur) return false;
        }
    }
    return !stack.length;
};

// generateParenthesis(2);

var generateParenthesis = function(n){
    var result = [];
    recursion(0,n,0,'');
    return result;

    function recursion(leftCount,n,rightCount,s){
       if(leftCount+rightCount===2*n) {
           result.push(s);
           return;
       }

        if(leftCount<n)
            recursion(leftCount+1,n,rightCount,s+'(');

        if(leftCount>rightCount)
           recursion(leftCount,n,rightCount+1,s+')');

    }
}

var frequencySort = function(s) {
    var dic = {},maxCount = 0,result = '';
    for(var i=0;i<s.length;i++){
        dic[s[i]] = dic[s[i]]? dic[s[i]]+1:1;
    }
    var curDic = Object.keys(dic).reduce(function(prev,chr){
        if(!prev[dic[chr]]) prev[dic[chr]] = [chr];
        else prev[dic[chr]].push(chr);
        return prev;  //attention2: 别忘了return
    },{});
    //curDic: {1:['t','r'],2:['e']}
    Object.keys(curDic).sort(function(a,b){return b-a}) //attention1: 降序排列
            .forEach(function(count){
        var strOfCount = curDic[count].map(function(chr){
            var temp = '';
            for(i=0;i<count;i++) temp+=chr;
            return temp;
        }).join('');
        result += strOfCount;
    })
    return result;

};
// frequencySort('tree')

var topKFrequent = function(nums, k) {
    var dic = {},revertDic = {},maxCount = 0;
    var result = [];
    for(var i=0;i<nums.length;i++){
        var countInDic = dic[nums[i]];
        dic[nums[i]] = countInDic? countInDic+1:1;
        maxCount = Math.max(maxCount,dic[nums[i]]);
    }
    revertDic = Object.keys(dic).reduce(function(prev,chr){
        var count = dic[chr];
        if(!prev[count]) prev[count] = [];
        prev[count].push(parseInt(chr));
        return prev;
    },{});
    var topK = maxCount;
    for(i=k;i>0;topK--){
        if(revertDic[topK]) {
            result = result.concat(revertDic[topK]);
            i--;
        }
    }
    return result;
};

// topKFrequent([1,1,1,2,2,3],2);

var findKthLargest2 = function(nums, k) {
     quick_sort(nums,0,nums.length-1);
     return nums[k-1];

    function quick_sort(nums,start,end){
        if(end>start){
            var insertIndex  = partition(nums,start,end);
            quick_sort(nums,start,insertIndex-1);
            quick_sort(nums,insertIndex+1,end);
        }
    }
    function partition(nums,start,end){
        var pivot = nums[start];
        while(start<end){
            while(nums[end]<pivot && start<end) end--;
            if(start<end) {
                nums[start] = nums[end];
                start++;
            }
            while(nums[start]>pivot && start<end) start++;
            if(start<end) {
                nums[end] = nums[start];
                end--;
            }
        }
        nums[start] = pivot;
        return start;
    }
    function swap(nums,i,j){
        var temp = nums[j];
        nums[j] = nums[i];
        nums[i] = temp;
    }
};

var findKthLargest = function(nums, k) {
    quick_sort(nums,0,nums.length-1);
    return nums[k-1];

    function quick_sort(nums,start,end){
        if((end-start+1)<=3){
            insertSort(nums,start,end);
        }
        else{
            var pivot = findMedian(nums,start,end);
            var insertIndex  = partition(nums,pivot,start+1,end-2);
            swap(nums,insertIndex,end-1);
            quick_sort(nums,start,insertIndex-1);
            quick_sort(nums,insertIndex+1,end);
        }

    }
    function partition(nums,pivot,start,end){
    //&& start>0 && end<nums.length
        while(true){
            while(nums[start]>pivot) start++; //最多是越过[]，碰到自己，start= end+1
            while(nums[end]<pivot) end--;
            if(start<end) swap(nums,start++,end--);   //别忘了
            else break;
        }
        return start;
    }
    function insertSort(arr,start,end){
        for(var i=start+1;i<=end;i++){
            var cur = arr[i];
            for(var j=i-1;j>=0;j--){
                if(cur>arr[j]) arr[j+1] = arr[j];
                else break;
            }
            arr[j+1] = cur;

        }
    }

    function findMedian(nums,start,end){
        var middle = start+ Math.floor((end-start)/2);
        if(nums[start]<nums[middle]) swap(nums,start,middle);
        if(nums[start]<nums[end]) swap(nums,start,end);
        if(nums[middle]<nums[end]) swap(nums,middle,end);

        swap(nums,middle,end-1);
        return nums[end-1];
    }

    function swap(nums,i,j){
        var temp = nums[j];
        nums[j] = nums[i];
        nums[i] = temp;
    }

};

// findKthLargest([3,3,3,3,3,3,3,3,3],1);
var firstMissingPositive = function(nums) {
    debugger;
    if(!nums.length) return 1;
    function swap(nums,i,j){
        var temp = nums[j];
        nums[j] = nums[i];
        nums[i] = temp;
    }
    for(var i=0;i<nums.length;i++){
        while(nums[i]!==(i+1)){
            if(nums[i]<=0 || nums[i]>nums.length || nums[i] == nums[nums[i] - 1]) break;
            else swap(nums,i,nums[i]-1);
        }
    }
    for(i=0;i<nums.length;i++){
        if(nums[i]!==(i+1)) return i+1;
    }
    return nums.slice(-1)[0]+1;
};

firstMissingPositive([1,0])
// maxSubArray(nums);
/***********************************************/
/*
var permute = function(nums) {
    var result = [];
    nums.sort(function(a,b){ return a-b});

    nextPermutation(nums,result);
    return result;

};


var nextPermutation = function(nums,result) {

    var i=nums.length-1,j = i;
    //降序排列的数组，左边一个数字即为要更改的部分。
    while(nums[i-1]>=nums[i]) i--;
    var baseIndex = i-1;

    //对右边排序。降序数组变为升序排列，用左右夹逼交换即可。
    while(i<j && i>=0){
        swap.call(nums,i,j);
        i++;
        j--;
    }

    //排序后找到第一个比baseIndex大的进行交换。交换需要注意baseIndex是否是数组以内的
    if(baseIndex>=0){
        i= baseIndex+1;
        while(nums[i]<=nums[baseIndex])
            i++;
        swap.call(nums,i,baseIndex);

        var curResult = [].concat(nums);
        result.push(curResult);
        nextPermutation(nums,result);
    }else return;



};


function swap(i,j){
    var temp;
    temp = this[j];
    this[j] = this[i];
    this[i] = temp;
    return this;
}

var arr = [1,2,3];
permute(arr);

*/
</script>
</body>
</html>